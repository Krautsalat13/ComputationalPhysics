\section{Code}

In the section about the simulation model, the use of multiprocessing was not discussed. As this only makes the code more efficient, it was of no avail to explain it there. The basic idea is to calculate the same function with different arguments parallel. This has the advantage that the runtime is reduced drastically for five different inputs.


%TODO comment on code


\begin{lstlisting}[language=Python]
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jul 14 15:46:58 2023

@author: tamilarasan
"""
import numpy as np
import matplotlib.pyplot as plt
from numba import njit, vectorize, float64
import time

start = time.time()
from multiprocessing import Pool
import os 
os.environ["PATH"] += os.pathsep + '/Library/TeX/texbin'

plt.rcParams["text.usetex"] = True
plt.rcParams["font.family"] = "times new roman"
plt.rcParams["font.size"] = "18"

pi      = np.pi  



Delta = 0.025
L = 1201
tau = 0.00025
m = 40000


def solve(Input): 
    Omega, sigma, x0 = Input
    
    c = np.cos(tau/(4*Delta**2))
    s = 1j*np.sin(tau/(4*Delta**2))
    M = np.array([[c,s],[s,c]], dtype=np.complex128) 
    
    x = np.linspace(-15,15,L)
    @njit
    def Phi0(x):
        return (pi*sigma**2)**(-1/4)*np.exp(-(x-x0)**2/(2*sigma**2))
    
    Phi = np.array(Phi0(x)).astype(np.complex128) 
    
    @njit
    def V(x):
        return 1/2*Omega**2*x**2
    
    Vvec= np.vectorize(V)    
    Vx = np.exp(-1j*tau*(Delta**(-2)+Vvec(x)))
    
    @njit
    def dt(phi):
        for k in range(0,len(phi)-1,2):             #K1
            phi[k:k+2] = np.dot(M,phi[k:k+2])
        for k in range(0,len(phi)-1,2):             #K2
            phi[k+1:k+3] = np.dot(M,phi[k+1:k+3])
        phi = Vx*phi                                #V part
        for k in range(0,len(phi)-1,2):             #K2
            phi[k+1:k+3] = np.dot(M,phi[k+1:k+3])
        for k in range(0,len(phi)-1,2):             #K1
            phi[k:k+2] = np.dot(M,phi[k:k+2])
        return phi
    
    X = np.zeros(m+1)
    Xsq = np.zeros(m+1)
    tprint = [0,2,4,6,8,10]
    Pt = []
    for i in range(m):
        P = np.abs(Phi)**2
        if round(i*tau,5) in tprint:
            Pt+= [P]
        X[i] = np.sum(x*P*Delta)
        Xsq[i] = np.sum(x**2*P*Delta)
        Phi = dt(Phi)
    P = np.abs(Phi)**2
    Pt += [P]
    X[m] = np.sum(x*P*Delta)
    Xsq[m] = np.sum(x**2*P*Delta)
    plt.show()
    return X,Xsq,Pt


    

def plot(task,arg):
    Omega, sigma, x0 = arg
    legend = [[1,1,0],[1,2,0],[2,2,2]]
    X,Xsq,P = task
    t = np.linspace(0,m*tau,m+1)
    x = np.linspace(-15,15,L)
    xth = x0*np.cos(Omega*t)
    xsqth = 1/(2*Omega**2*sigma**2)*(np.sin(Omega*t))**2+ 1/2*(sigma**2+2*x0**2)*(np.cos(Omega*t))**2
    tprint = [0,2,4,6,8,10]
    
    plt.grid()
    plt.plot(t, X, label =r"Simulation $\langle x(t) \rangle$", color ="tab:blue")
    plt.plot(t, xth, label = r"Theory $\langle x(t) \rangle$", color = "tab:blue", ls = "--",alpha = 0.5)
    plt.plot(t, Xsq-X**2,label =r"Simulation $\langle x(t)^2 \rangle-\langle x(t) \rangle^2$", color ="tab:orange")
    plt.plot(t, xsqth-xth**2, label = r"Theory $\langle x(t)^2 \rangle-\langle x(t) \rangle^2$",alpha = 0.5, color = "tab:orange",ls = "--")
    plt.xlabel("t")
    plt.ylabel("Average and Variance")
    plt.title(r"$\Omega$ = "+str(Omega)+r", $\sigma$ = "+str(sigma)+r", $x_0$ = "+str(x0))
    if arg in legend:
        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    plt.savefig(f"plot/Omega{Omega}_sigma{sigma}_x0{x0}_Averages.pdf",bbox_inches='tight')
    plt.show()
    
    
    plt.grid()
    plt.plot(t, X-xth, label = r"$\langle x(t)_{sim} \rangle - \langle x(t)_{theo} \rangle$", color = "tab:blue")
    plt.plot(t, Xsq-X**2 - (xsqth-xth**2),label =r"$Var(x_{sim}) -Var(x_{theo})$", color ="tab:orange")
    plt.xlabel("t")
    plt.ylabel("Difference of Average and Variance")
    plt.title(r"$\Omega$ = "+str(Omega)+r", $\sigma$ = "+str(sigma)+r", $x_0$ = "+str(x0))
    if arg in legend:
        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    plt.savefig(f"plot/Omega{Omega}_sigma{sigma}_x0{x0}_Averages_expect.pdf",bbox_inches='tight')
    plt.show()
    
    for i in range(6):
        np.save(f"Data/tami_t{tprint[i]}_params{Omega}{sigma}{x0}.npy", P[i])
        plt.plot(x,P[i], label = "t = "+str(tprint[i]))
    plt.title(r"$\Omega$ = "+str(Omega)+r", $\sigma$ = "+str(sigma)+r", $x_0$ = "+str(x0))
    plt.xlabel("x")
    plt.xlim(-5,5)
    plt.grid()
    plt.ylabel("Probability")
    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    plt.savefig(f"plot/Omega{Omega}_sigma{sigma}_x0{x0}_Probabilities.pdf",bbox_inches='tight')
    plt.show()
    return 0

if __name__ == '__main__':
    pool = Pool()
    args = [[1,1,0],[1,1,1],[1,2,0],[2,1,1],[2,2,2]]
    Sol = pool.map(solve, args)

    for i in range(5):
        plot(Sol[i],args[i])


end = time.time()
print(end - start)
\end{lstlisting}
